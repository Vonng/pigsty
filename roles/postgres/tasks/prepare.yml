---
#------------------------------------------------------------------------------
# check postgres instance precondition
#  --- empty  ---> clean ---> init
#  --- exist  ^--> [pg_clean=true] ---> abort entire playbook (for the sake of data safety)
#             ^--> [action=skip]  ---> skip current play for this instance
#             ^--> [action=clean] ---> clean ---> init
#------------------------------------------------------------------------------
- name: Check postgres existance
  tags: pg_check
  block:

    - name: Check for existing postgres instance
      command: 'ss -tp state listening sport = :{{ pg_port }}'
      any_errors_fatal: true
      register: check_pg_port_result

    - name: Set fact whether pg port is open
      connection: local
      set_fact:
        pg_exists: "{{ 'post' in check_pg_port_result.stdout }}"

    # when any running instance exists, abort play in two cases:
    # 2. pg_clean = false
    # 1. pg_safeguard = true          (global flag to prevent accidentally purge)

    - name: Abort due to existing postgres instance
      connection: local
      when: pg_exists|bool and (pg_safeguard|bool or not pg_clean|bool)
      any_errors_fatal: true
      fail: msg="Abort because pg instance {{ pg_cluster }}-{{ pg_seq }} @ {{ inventory_hostname }} is running, use -e pg_clean=true"


#------------------------------------------------------------------------------
# purge existing postgres
#------------------------------------------------------------------------------
# DANGEROUS! remove all postgres data of target machine
# BUT, this is your choice
- name: Cleanup postgresql
  tags: pg_clean
  become: yes
  block:

    - name: CLEAN RUNNING POSTGRESQL INSTANCE <DANGEROUSE!>
      # connection: local # leave some time for manual intervention
      when: not pg_safeguard and pg_exists and pg_clean  # DANGEROUS!
      debug:
        msg: "[DANGEROUS] RUNNING PGSQL INSTANCE {{ pg_cluster }}-{{ pg_seq }} @ {{ inventory_hostname }} WILL BE PURGED!"


    - name: Shutdown existing postgres service
      shell: |
        # first, gracefully stop related service
        systemctl stop haproxy
        systemctl stop patroni
        systemctl stop postgres
        systemctl stop pgbouncer
        systemctl stop pg_exporter
        systemctl stop pgbouncer_exporter

        # then, manually stop service if still exists
        if ps -u postgres -o pid:1,command | grep -E 'postmaster|postgres:|-D'  | grep checkpointer ; then
            pg_ctl -D {{ pg_data }} stop --mode=immediate
            ps -u postgres -o pid:1,command | grep -E 'postmaster|postgres:|-D' | awk '{print $1}' | xargs kill -9
        fi

        if ps -u postgres -o pid:1,command | grep -E 'postmaster|postgres:|-D'  | grep checkpointer ; then
            ps -u postgres -o pid:1,command | grep -E 'postmaster|postgres:|-D' | awk '{print $1}' | xargs kill -9
            sleep 5 # if still alive, leave 5s grace peroid and force a kill -9
        fi

        if ps -u postgres -o pid:1,command | grep -E 'postmaster|postgres:|-D'  | grep checkpointer ; then
            exit 1  # report failure if still alive
        fi
        exit 0

    - name: Remove registerd consul service
      ignore_errors: yes
      shell: |
        rm -rf /etc/consul.d/svc-*.json
        /usr/bin/consul reload
        exit 0

    # when cleanup primary, remove consul metadata in consul
    - name: Remove postgres metadata in consul
      ignore_errors: true
      when: pg_role == 'primary' and pg_dcs_type == 'consul'
      shell: |
        consul kv delete -recurse {{ pg_namespace }}/{{ pg_cluster }}

    - name: Remove postgres metadata in etcd
      ignore_errors: true
      when: pg_role == 'primary' and pg_dcs_type == 'etcd'
      shell: |
        ETCDCTL_ENDPOINTS="{% for k,v in dcs_servers.items() %}{% if not loop.first %},{% endif %}{{ v }}:2379{% endfor %}"
        etcdctl rm -r {{ pg_namespace }}/{{ pg_cluster }}

    # TODO: only remove necessary dir instead of all
    - name: Remove existing postgres data
      file: path={{ item }} state=absent
      with_items:
        - /pg
        - "{{ pg_fs_main }}/postgres"
        - "{{ pg_fs_bkup }}/postgres"
        - /etc/pgbouncer
        - /var/log/pgbouncer
        - /var/run/pgbouncer



#------------------------------------------------------------------------------
# Create Directory
#------------------------------------------------------------------------------
# this assumes that
#   /pg is shortcut for postgres home
#   {{ pg_fs_main }} contains the main data             (MUST ALREADY MOUNTED)
#   {{ pg_fs_bkup }} contains archive and backup data   (MUST ALREADY MOUNTED)
#   cluster-version is the default parent folder for pgdata (e.g pg-test-12)
#------------------------------------------------------------------------------
# default variable:
#     pg_fs_main = /export           fast ssd
#     pg_fs_bkup = /var/backups      cheap hdd
#
#     /pg      -> /export/postgres/pg-test-12
#     /pg/data -> /export/postgres/pg-test-12/data
#------------------------------------------------------------------------------
- name: Create postgresql directories
  tags: pg_dir
  become: yes
  block:
    - name: Make sure main and backup dir exists
      file: path={{ item }} state=directory owner=root mode=0777
      with_items:
        - "{{ pg_fs_main }}"
        - "{{ pg_fs_bkup }}"

    # pg_cluster_dir:    "{{ pg_fs_main }}/postgres/{{ pg_cluster }}-{{ pg_version }}"
    - name: Create postgres directory structure
      file: path={{ item }} state=directory owner={{ pg_dbsu }} group=postgres mode=0700
      with_items:
        - "{{ pg_fs_main }}/postgres"
        - "{{ pg_cluster_dir }}"
        - "{{ pg_cluster_dir }}/bin"
        - "{{ pg_cluster_dir }}/log"
        - "{{ pg_cluster_dir }}/tmp"
        - "{{ pg_cluster_dir }}/conf"
        - "{{ pg_cluster_dir }}/data"
        - "{{ pg_cluster_dir }}/meta"
        - "{{ pg_cluster_dir }}/stat"
        - "{{ pg_cluster_dir }}/change"
        - "{{ pg_backup_dir }}/postgres"
        - "{{ pg_backup_dir }}/arcwal"
        - "{{ pg_backup_dir }}/backup"
        - "{{ pg_backup_dir }}/remote"

    - name: Create pgbouncer directory structure
      file: path={{ item }} state=directory owner={{ pg_dbsu }} group=postgres mode=0750
      with_items:
        - /etc/pgbouncer
        - /var/log/pgbouncer
        - /var/run/pgbouncer

    - name: Create links from pgbkup to pgroot
      file:
        src: "{{ pg_backup_dir }}/{{ item }}"
        dest: "{{ pg_cluster_dir }}/{{ item }}"
        state: link
      with_items:
        - arcwal
        - backup
        - remote

    - name: Create links from current cluster
      file:
        src: "{{ pg_cluster_dir }}"
        dest: /pg
        state: link

    # dummy file could be removed in case of disk-full
    # which cushion against immediate failure
    - name: Create dummy placeholder file
      tags: pg_dummy
      command: fallocate -l {{ pg_dummy_filesize }} /pg/dummy



#------------------------------------------------------------------------------
# Copy scripts
#------------------------------------------------------------------------------
- name: Copy postgresql scripts
  tags: pg_scripts
  become: yes
  block:
    - name: Copy postgres scripts to /pg/bin/
      copy: src=pg/ dest=/pg/bin/ owner={{ pg_dbsu }} group=postgres mode=0755

    - name: Copy pgsql profile to postgres home
      copy: src=pgsql_profile dest="{{ pg_dbsu_home }}/.pgsql_profile" owner={{ pg_dbsu }} group=postgres mode=0600

    - name: Copy psqlrc to postgres home
      copy: src=psqlrc dest="{{ pg_dbsu_home }}/.psqlrc" owner={{ pg_dbsu }} group=postgres mode=0600

...
